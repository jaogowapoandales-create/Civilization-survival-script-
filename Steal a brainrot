--=== SERVICES ===--
local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local RunService = game:GetService("RunService")
local LocalPlayer = Players.LocalPlayer
local PlayerGui = LocalPlayer:WaitForChild("PlayerGui")

--=== LOAD WIZARD UI ===--
local Library = loadstring(game:HttpGet("https://raw.githubusercontent.com/bloodball/-back-ups-for-libs/main/wizard"))()
local Window = Library:NewWindow("Steal a Brainrot")
local Tab = Window:NewSection("Bypass")

--=== MOVE GUI TO PLAYERGUI FOR DETECTION AVOIDANCE ===--
task.defer(function()
	local CoreGui = game:GetService("CoreGui")
	for _, gui in pairs(CoreGui:GetChildren()) do
		if gui.Name == "WizardUI" or gui.Name:lower():find("wizard") then
			gui.Parent = PlayerGui
			gui.Name = "SafeUI_" .. tostring(math.random(1000,9999))
			print("[Stealth] Moved Wizard UI to PlayerGui as", gui.Name)
		end
	end
end)

--=== STEALTH SPEED BYPASS ===--
local speedBypassConnection
local totalSpeed = 8
local steps = 4

Tab:CreateToggle("Stealth Speed Bypass (Fast)", function(enabled)
	if enabled then
		speedBypassConnection = RunService.RenderStepped:Connect(function()
			local character = LocalPlayer.Character
			if not character then return end

			local hrp = character:FindFirstChild("HumanoidRootPart")
			local humanoid = character:FindFirstChildOfClass("Humanoid")
			if not hrp or not humanoid or humanoid.Sit or humanoid.Health <= 0 then return end

			local moveDirection = humanoid.MoveDirection
			if moveDirection.Magnitude > 0 then
				local stepSize = totalSpeed / steps
				for _ = 1, steps do
					hrp.CFrame = hrp.CFrame + (moveDirection * stepSize)
					task.wait()
				end
			end
		end)
		print("[Stealth Speed] Enabled")
	else
		if speedBypassConnection then
			speedBypassConnection:Disconnect()
			speedBypassConnection = nil
		end
		print("[Stealth Speed] Disabled")
	end
end)

--=== TELEPORT (TP) BYPASS ===--
local tpBypassConnection
local lastSafeCFrame = nil

Tab:CreateToggle("Teleport Bypass", function(enabled)
	if enabled then
		tpBypassConnection = RunService.Heartbeat:Connect(function()
			local character = LocalPlayer.Character
			if not character then return end

			local hrp = character:FindFirstChild("HumanoidRootPart")
			local humanoid = character:FindFirstChildOfClass("Humanoid")
			if hrp and humanoid and humanoid.Health > 0 then
				lastSafeCFrame = hrp.CFrame
			end
		end)

		RunService.Heartbeat:Connect(function()
			local character = LocalPlayer.Character
			if not character or not lastSafeCFrame then return end

			local hrp = character:FindFirstChild("HumanoidRootPart")
			if hrp and (hrp.Position - lastSafeCFrame.Position).Magnitude > 10 then
				hrp.CFrame = lastSafeCFrame
				print("[TP Bypass] Blocked teleport reset")
			end
		end)
	else
		if tpBypassConnection then
			tpBypassConnection:Disconnect()
			tpBypassConnection = nil
		end
	end
end)

--=== AUTO INTERACT (IN FRONT ONLY) ===--
local autoInteractEnabled = false
local INTERACT_DISTANCE = 10
local INTERACT_ANGLE = 60 -- degrees

-- Is prompt in front?
local function isInFront(root, targetPosition)
	local lookVector = root.CFrame.LookVector
	local toTarget = (targetPosition - root.Position).Unit
	local dot = lookVector:Dot(toTarget)
	local angle = math.deg(math.acos(dot))
	return angle <= (INTERACT_ANGLE / 2)
end

-- Interaction loop
task.spawn(function()
	while true do
		if autoInteractEnabled then
			local character = LocalPlayer.Character
			local hrp = character and character:FindFirstChild("HumanoidRootPart")
			if hrp then
				for _, prompt in ipairs(workspace:GetDescendants()) do
					if prompt:IsA("ProximityPrompt") and prompt.Enabled then
						local part = prompt.Parent:IsA("BasePart") and prompt.Parent or nil
						if part then
							local dist = (hrp.Position - part.Position).Magnitude
							if dist <= INTERACT_DISTANCE and isInFront(hrp, part.Position) then
								pcall(function()
									prompt:InputHoldBegin()
									task.wait(0.1)
									prompt:InputHoldEnd()
								end)
							end
						end
					end
				end
			end
		end
		task.wait(0.2)
	end
end)

Tab:CreateToggle("Auto Interact (Front Only)", function(value)
	autoInteractEnabled = value
	print("[Auto Interact] Enabled:", value)
end)

--=== REMOTE EVENT BLOCK (Kick / Ban / TP Protection) ===--
local remoteConnections = {}

local function blockRemotes(enable)
	if not enable then
		for _, conn in ipairs(remoteConnections) do
			conn:Disconnect()
		end
		remoteConnections = {}
		return
	end

	for _, obj in pairs(ReplicatedStorage:GetDescendants()) do
		if obj:IsA("RemoteEvent") then
			local conn = obj.OnClientEvent:Connect(function(...)
				local args = {...}
				if #args > 0 and typeof(args[1]) == "string" then
					local msg = args[1]:lower()
					if msg:find("kick") or msg:find("ban") or msg:find("teleport") then
						warn("[RemoteBlock] Blocked:", msg)
						return
					end
				end
			end)
			table.insert(remoteConnections, conn)
		elseif obj:IsA("RemoteFunction") then
			local oldInvoke = obj.InvokeServer
			obj.InvokeServer = function(self, ...)
				local args = {...}
				for _, v in ipairs(args) do
					if typeof(v) == "string" and v:lower():find("kick") then
						warn("[RemoteBlock] Blocked suspicious remote function call")
						return nil
					end
				end
				return oldInvoke(self, ...)
			end
		end
	end
end

Tab:CreateToggle("Block Kick / Ban / TP Remotes", function(enabled)
	blockRemotes(enabled)
end, true)

--=== ANTI-KICK & ADONIS CLEANUP ===--

-- Remove Adonis LocalScripts
for _, v in ipairs(LocalPlayer:GetChildren()) do
	if v:IsA("LocalScript") and v.Name:lower():find("adonis") then
		v:Destroy()
		warn("[Adonis Bypass] Removed LocalScript:", v.Name)
	end
end

-- Patch Kick
do
	local mt = getrawmetatable(LocalPlayer)
	local oldIndex = mt.__index

	setreadonly(mt, false)

	mt.__index = function(self, key)
		if self == LocalPlayer and key == "Kick" then
			return function() warn("[AntiKick] Blocked Kick") end
		end
		return oldIndex(self, key)
	end

	setreadonly(mt, true)
end
